(ns gershwin.test-gershwin.core
  (:require-words [gershwin.test :refer [unit-test]]))

: suite [-- ?]
  ;; Invocation/Application
  #[ 42 ] #[ {:answer 42} :answer apply ] unit-test
  #[ 42 ] #[ 21 21 clojure.core/+ apply2 ] unit-test
  #[ "bazbarfoo" ] #[ "foo" "bar" "baz" clojure.core/str apply3 ] unit-test
  #[ 1 ] #[ 3 2 clojure.core/- apply-swap ] unit-test

  ;; Types
  [] #[ true ] #[ 'foo symbol? ] unit-test
  #[ false ] #[ :foo symbol? ] unit-test
  #[ true ] #[ (fn [] 42) function? ] unit-test
  #[ false ] #[ :foo function? ] unit-test
  #[ false ] #[ "foo" function? ] unit-test

  ;; Math
  #[ 42 ] #[ 21 21 + ] unit-test
  #[ 441 ] #[ 21 21 * ] unit-test
  #[ 1 ] #[ 41 41 div ] unit-test
  #[ 2/3 ] #[ 2 3 div ] unit-test

  ;; Equality
  #[ true ] #[ (Object.) dup = ] unit-test
  #[ true ] #[ "foo" "foo" = ] unit-test
  #[ true ] #[ :bar :bar = ] unit-test
  #[ true ] #[ 2 2 = ] unit-test
  #[ false ] #[ 2 2.0 = ] unit-test
  #[ true ] #[ 2 2.0 == ] unit-test
  #[ true ] #[ 4.5 45/10 == ] unit-test

  ;; Booleans
  #[ true ] #[ 42 boolean ] unit-test
  #[ true ] #[ 0 boolean ] unit-test
  #[ true ] #[ "" boolean ] unit-test
  #[ true ] #[ [] boolean ] unit-test
  #[ true ] #[ {} boolean ] unit-test
  #[ false ] #[ nil boolean ] unit-test
  #[ false ] #[ false boolean ] unit-test
  #[ "yes" ] #[ 42 "yes" "no" ? ] unit-test
  #[ #[ "yes" ] ] #[ 42 #[ "yes" ] #[ "no" ] ? ] unit-test
  #[ "yes" ] #[ 42 #[ "yes" ] #[ "no" ] if ] unit-test
  #[ "no" ] #[ 42 #[ "yes" ] #[ "no" ] if-not ] unit-test
  #[ "yes" ] #[ true #[ "yes" ] when ] unit-test
  #[ "no" ] #[ false #[ "no" ] when-not ] unit-test
  #[ false ] #[ nil nil or ] unit-test .
